--- "D:\\users\\lucas\\Desktop\\dev\\python\\pest\\.patches\\rodi\\__init__.py.original"	2023-11-24 01:40:13.787287300 -0300
+++ "D:\\users\\lucas\\Desktop\\dev\\python\\pest\\.patches\\rodi/__init__.py"	2023-11-24 01:39:23.859523600 -0300
@@ -20,6 +20,11 @@
     get_type_hints,
 )
 
+if sys.version_info >= (3, 9):  # pragma: no cover
+    from typing import _no_init_or_replace_init as _no_init
+elif sys.version_info >= (3, 8):  # pragma: no cover
+    from typing import _no_init
+
 try:
     from typing import Protocol
 except ImportError:  # pragma: no cover
@@ -475,7 +480,12 @@
         assert (
             reg is not None
         ), f"A resolver for type {class_name(desired_type)} is not configured"
-        return reg(context)
+        resolver = reg(context)
+
+        # add the resolver to the context, so we can find it
+        # next time we need it
+        context.resolved[desired_type] = resolver
+        return resolver
 
     def _get_resolvers_for_parameters(
         self,
@@ -567,11 +577,23 @@
         """
         Returns a value indicating whether a class attribute should be ignored for
         dependency resolution, by name and value.
+        It's ignored if it's a ClassVar or if it's already initialized explicitly.
         """
-        try:
-            return value.__origin__ is ClassVar
-        except AttributeError:
-            return False
+        is_classvar = getattr(value, "__origin__", None) is ClassVar
+        is_initialized = getattr(self.concrete_type, key, None) is not None
+
+        return is_classvar or is_initialized
+
+    def _has_default_init(self):
+        init = getattr(self.concrete_type, "__init__", None)
+
+        if init is object.__init__:
+            return True
+
+        if sys.version_info >= (3, 8):  # pragma: no cover
+            if init is _no_init:
+                return True
+        return False
 
     def _resolve_by_annotations(
         self, context: ResolutionContext, annotations: Dict[str, Type]
@@ -599,7 +621,7 @@
         chain = context.dynamic_chain
         chain.append(concrete_type)
 
-        if getattr(concrete_type, "__init__") is object.__init__:
+        if self._has_default_init():
             annotations = get_type_hints(
                 concrete_type,
                 vars(sys.modules[concrete_type.__module__]),
@@ -1146,14 +1168,24 @@
             _map: Dict[Union[str, Type], Type] = {}
 
             for _type, resolver in self._map.items():
-                # NB: do not call resolver if one was already prepared for the type
-                assert _type not in context.resolved, "_map keys must be unique"
-
                 if isinstance(resolver, DynamicResolver):
                     context.dynamic_chain.clear()
 
-                _map[_type] = resolver(context)
-                context.resolved[_type] = _map[_type]
+                if _type in context.resolved:
+                    # assert _type not in context.resolved, "_map keys must be unique"
+                    # check if its in the map
+                    if _type in _map:
+                        # NB: do not call resolver if one was already prepared for the
+                        # type
+                        raise OverridingServiceException(_type, resolver)
+                    else:
+                        resolved = context.resolved[_type]
+                else:
+                    # add to context so that we don't repeat operations
+                    resolved = resolver(context)
+                    context.resolved[_type] = resolved
+
+                _map[_type] = resolved
 
                 type_name = class_name(_type)
                 if "." not in type_name:
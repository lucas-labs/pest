--- "D:\\users\\lucas\\Desktop\\dev\\python\\pest\\.patches\\rodi\\__init__.py.original"	2023-11-12 22:43:39.892416300 -0300
+++ "D:\\users\\lucas\\Desktop\\dev\\python\\pest\\.patches\\rodi/__init__.py"	2023-11-12 20:43:53.450989400 -0300
@@ -475,7 +475,12 @@
         assert (
             reg is not None
         ), f"A resolver for type {class_name(desired_type)} is not configured"
-        return reg(context)
+        resolver = reg(context)
+
+        # add the resolver to the context, so we can find it
+        # next time we need it
+        context.resolved[desired_type] = resolver
+        return resolver
 
     def _get_resolvers_for_parameters(
         self,
@@ -567,11 +572,12 @@
         """
         Returns a value indicating whether a class attribute should be ignored for
         dependency resolution, by name and value.
+        It's ignored if it's a ClassVar or if it's already initialized explicitly.
         """
-        try:
-            return value.__origin__ is ClassVar
-        except AttributeError:
-            return False
+        is_classvar = getattr(value, "__origin__", None) is ClassVar
+        is_initialized = getattr(self.concrete_type, key, None) is not None
+
+        return is_classvar or is_initialized
 
     def _resolve_by_annotations(
         self, context: ResolutionContext, annotations: Dict[str, Type]
@@ -1146,14 +1152,24 @@
             _map: Dict[Union[str, Type], Type] = {}
 
             for _type, resolver in self._map.items():
-                # NB: do not call resolver if one was already prepared for the type
-                assert _type not in context.resolved, "_map keys must be unique"
-
                 if isinstance(resolver, DynamicResolver):
                     context.dynamic_chain.clear()
 
-                _map[_type] = resolver(context)
-                context.resolved[_type] = _map[_type]
+                if _type in context.resolved:
+                    # assert _type not in context.resolved, "_map keys must be unique"
+                    # check if its in the map
+                    if _type in _map:
+                        # NB: do not call resolver if one was already prepared for the
+                        # type
+                        raise OverridingServiceException(_type, resolver)
+                    else:
+                        resolved = context.resolved[_type]
+                else:
+                    # add to context so that we don't repeat operations
+                    resolved = resolver(context)
+                    context.resolved[_type] = resolved
+
+                _map[_type] = resolved
 
                 type_name = class_name(_type)
                 if "." not in type_name: